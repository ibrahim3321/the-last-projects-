name: Provision Infra (AKS/AGIC/ArgoCD)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment (dev or prod)"
        required: true
        default: "dev"
        type: choice
        options: [dev, prod]

jobs:
  infra:
    runs-on: ubuntu-latest
    env:
      ENV: ${{ inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Write tfvars from secret
        run: |
          if [ "$ENV" = "dev" ]; then
            echo "${{ secrets.DEV }}" > terraform/env.tfvars
          else
            echo "${{ secrets.PROD }}" > terraform/env.tfvars
          fi
          echo "Wrote terraform/env.tfvars:"
          cat terraform/env.tfvars

      - name: Terraform Init/Plan/Apply
        working-directory: terraform
        env:
          ARM_USE_OIDC: true
        run: |
          terraform init
          terraform plan -var-file=env.tfvars -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Extract TF outputs (jq)
        working-directory: terraform
        run: |
          terraform output -json > tfout.json
          cat tfout.json
          AKS_NAME=$(jq -r '.aks_cluster_name.value' tfout.json)
          RG=$(jq -r '.resource_group_name.value // empty' tfout.json)
          # If RG not output by module, reconstruct from tfvars:
          if [ -z "$RG" ]; then
            RG=$(grep -E '^ *resource_group_name' env.tfvars | awk -F\" '{print $2}')
          fi
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RG" >> $GITHUB_ENV

      - name: Get kubeconfig for AKS
        run: |
          az aks get-credentials -n "$AKS_NAME" -g "$RESOURCE_GROUP" --overwrite-existing

      - name: Enable AGIC (Application Gateway Ingress Controller)
        run: |
          # Create a simple App Gateway addon (new VNet/subnet is created by AKS if not present)
          # Adjust names/cidr as you prefer or move into Terraform later.
          az aks enable-addons \
            -a ingress-appgw \
            -n "$AKS_NAME" \
            -g "$RESOURCE_GROUP" \
            --appgw-name "${AKS_NAME}-appgw" \
            --appgw-subnet-cidr "10.225.0.0/16"

      - name: Install Argo CD (Helm)
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          helm upgrade -i argocd argo/argo-cd \
            --namespace argocd \
            --wait \
            --timeout 10m

      - name: Install Sealed-Secrets (Helm)
        run: |
          kubectl create namespace sealed-secrets --dry-run=client -o yaml | kubectl apply -f -
          helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets
          helm repo update
          helm upgrade -i sealed-secrets sealed-secrets/sealed-secrets \
            --namespace sealed-secrets \
            --wait \
            --timeout 10m

      - name: Create environment namespaces
        run: |
          kubectl create namespace dev --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace prod --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

      - name: Bootstrap Root Argo App
        run: |
          kubectl apply -f aks-yaml/argocd/root-app.yaml -n argocd
