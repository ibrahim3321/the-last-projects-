name: CI → Infra → Deploy (branch-friendly)

on:
  push:
    branches: [ main, feature/ci-cd ]
  workflow_dispatch:
    inputs:
      env:
        description: "dev or prod (overrides branch mapping)"
        type: choice
        options: [dev, prod]
        required: false
      enable_agic:
        description: "Enable AGIC via az aks enable-addons"
        type: choice
        options: [ "yes", "no" ]
        default: "yes"
      pin_sha:
        description: "Pin images to current commit SHA"
        type: choice
        options: [ "yes", "no" ]
        default: "yes"

env:
  REGISTRY_FQDN_SUFFIX: azurecr.io

jobs:
  select-env:
    runs-on: ubuntu-latest
    outputs:
      ENV: ${{ steps.pick.outputs.ENV }}
    steps:
      - name: Choose environment
        id: pick
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.env }}" ]; then
            ENV="${{ github.event.inputs.env }}"
          else
            case "${GITHUB_REF_NAME}" in
              main) ENV=prod ;;
              feature/ci-cd) ENV=dev ;;
              *) ENV=dev ;;
            esac
          fi
          echo "ENV=$ENV" >> $GITHUB_OUTPUT
          echo "Selected ENV=$ENV"

  build:
    needs: [select-env]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      ACR_FQDN: ${{ steps.acr.outputs.ACR_FQDN }}
      IMAGE_TAG_SUFFIX: ${{ steps.meta.outputs.IMAGE_TAG_SUFFIX }}
      ENV: ${{ needs.select-env.outputs.ENV }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Derive ACR FQDN and login
        id: acr
        run: |
          ACR_NAME="${{ secrets.ACR_NAME }}"
          echo "ACR_FQDN=${ACR_NAME}.${REGISTRY_FQDN_SUFFIX}" >> $GITHUB_OUTPUT
          az acr login --name "${ACR_NAME}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Metadata (labels/tags)
        id: meta
        run: |
          ENV="${{ needs.select-env.outputs.ENV }}"
          echo "IMAGE_TAG_SUFFIX=${GITHUB_SHA}-${ENV}" >> $GITHUB_OUTPUT

      # Backend
      - name: Build & push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ steps.acr.outputs.ACR_FQDN }}/backend:latest-${{ needs.select-env.outputs.ENV }}
            ${{ steps.acr.outputs.ACR_FQDN }}/backend:${{ steps.meta.outputs.IMAGE_TAG_SUFFIX }}
          cache-from: type=registry,ref=${{ steps.acr.outputs.ACR_FQDN }}/backend:buildcache
          cache-to: type=registry,ref=${{ steps.acr.outputs.ACR_FQDN }}/backend:buildcache,mode=max

      # Frontend
      - name: Build & push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ steps.acr.outputs.ACR_FQDN }}/frontend:latest-${{ needs.select-env.outputs.ENV }}
            ${{ steps.acr.outputs.ACR_FQDN }}/frontend:${{ steps.meta.outputs.IMAGE_TAG_SUFFIX }}
          cache-from: type=registry,ref=${{ steps.acr.outputs.ACR_FQDN }}/frontend:buildcache
          cache-to: type=registry,ref=${{ steps.acr.outputs.ACR_FQDN }}/frontend:buildcache,mode=max

      # Callmebot adapter
      - name: Build & push callmebot-adapter
        uses: docker/build-push-action@v5
        with:
          context: ./aks-yaml/callmebot
          push: true
          tags: |
            ${{ steps.acr.outputs.ACR_FQDN }}/callmebot-adapter:latest-${{ needs.select-env.outputs.ENV }}
            ${{ steps.acr.outputs.ACR_FQDN }}/callmebot-adapter:${{ steps.meta.outputs.IMAGE_TAG_SUFFIX }}
          cache-from: type=registry,ref=${{ steps.acr.outputs.ACR_FQDN }}/callmebot-adapter:buildcache
          cache-to: type=registry,ref=${{ steps.acr.outputs.ACR_FQDN }}/callmebot-adapter:buildcache,mode=max

  infra:
    needs: [build]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TF_IN_AUTOMATION: "true"
    outputs:
      AKS_NAME: ${{ steps.aksnames.outputs.AKS }}
      RG_NAME:  ${{ steps.aksnames.outputs.RG }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Pull external ACR id
        id: acr
        run: |
          ACR_ID=$(az acr show -n "${{ secrets.ACR_NAME }}" --query id -o tsv)
          echo "ACR_ID=$ACR_ID" >> $GITHUB_OUTPUT

      - name: Write env.auto.tfvars from secret
        working-directory: ./terraform
        run: |
          ENV="${{ needs.build.outputs.ENV }}"
          if [ "$ENV" = "prod" ]; then
            printf "%s\n" '${{ secrets.PROD }}' > env.auto.tfvars
          else
            printf "%s\n" '${{ secrets.DEV }}' > env.auto.tfvars
          fi
          echo 'acr_id = "${{ steps.acr.outputs.ACR_ID }}"' >> env.auto.tfvars

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform Init/Plan/Apply
        working-directory: ./terraform
        run: |
          terraform init -upgrade
          terraform plan -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Resolve AKS RG/name from tfvars
        id: aksnames
        run: |
          ENV="${{ needs.build.outputs.ENV }}"
          if [ "$ENV" = "prod" ]; then
            printf "%s\n" '${{ secrets.PROD }}' > .tfvars.tmp
          else
            printf "%s\n" '${{ secrets.DEV }}' > .tfvars.tmp
          fi
          RG=$(grep -E '^\s*resource_group_name' .tfvars.tmp | sed -E 's/.*=\s*"([^"]+)".*/\1/')
          PREFIX=$(grep -E '^\s*resource_prefix' .tfvars.tmp | sed -E 's/.*=\s*"([^"]+)".*/\1/')
          echo "RG=$RG" >> $GITHUB_OUTPUT
          echo "AKS=${PREFIX}-aks" >> $GITHUB_OUTPUT

      - name: (Optional) Enable AGIC
        if: ${{ github.event.inputs.enable_agic == 'yes' || github.event_name != 'workflow_dispatch' }}
        run: |
          AKS_NAME="${{ steps.aksnames.outputs.AKS }}"
          RESOURCE_GROUP="${{ steps.aksnames.outputs.RG }}"
          az aks enable-addons \
            -a ingress-appgw \
            -n "$AKS_NAME" \
            -g "$RESOURCE_GROUP" \
            --appgw-name "${AKS_NAME}-appgw" \
            --appgw-subnet-cidr "10.225.0.0/16"

  deploy:
    needs: [infra, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      REGISTRY_FQDN_SUFFIX: azurecr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS kubeconfig
        run: |
          az aks get-credentials \
            -g "${{ needs.infra.outputs.RG_NAME }}" \
            -n "${{ needs.infra.outputs.AKS_NAME }}" \
            --admin --overwrite-existing

      - name: Install tools (helm, kubeseal, yq, kustomize)
        run: |
          sudo snap install helm --classic
          KUBSEAL_VERSION="0.27.2"
          curl -L -o kubeseal https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBSEAL_VERSION}/kubeseal-linux-amd64
          sudo install -m 0755 kubeseal /usr/local/bin/kubeseal
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          KUSTOMIZE_VERSION="5.4.2"
          curl -sSLo kustomize.tar.gz https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv${KUSTOMIZE_VERSION}/kustomize_v${KUSTOMIZE_VERSION}_linux_amd64.tar.gz
          tar -xzf kustomize.tar.gz
          sudo install -m 0755 kustomize /usr/local/bin/kustomize

      - name: Install Sealed-Secrets controller
        run: |
          helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets
          helm upgrade -i sealed-secrets sealed-secrets/sealed-secrets \
            --namespace kube-system --create-namespace --wait --timeout 10m

      - name: Fetch Sealed-Secrets cert
        run: kubeseal --controller-namespace kube-system --controller-name sealed-secrets --fetch-cert > pubcert.pem

      - name: Prepare env folder
        run: mkdir -p "aks-yaml/secrets/${{ needs.build.outputs.ENV }}"

      - name: Write plain Secret yamls (from repo secrets)
        run: |
          printf "%s\n" '${{ secrets.SLACK_WEBHOOK_SECRETS }}' > /tmp/slack.yaml
          printf "%s\n" '${{ secrets.CALLMEBOT_SECRETS }}'     > /tmp/callmebot.yaml
          printf "%s\n" '${{ secrets.MSSQL_SECRETS }}'         > /tmp/mssql.yaml
          printf "%s\n" '${{ secrets.GRAFANA_CREDENTILALS }}'  > /tmp/grafana.yaml

      - name: Seal secrets → commit
        run: |
          ENV="${{ needs.build.outputs.ENV }}"
          for s in slack callmebot mssql grafana; do
            kubeseal --format yaml --cert pubcert.pem < "/tmp/${s}.yaml" > "aks-yaml/secrets/${ENV}/${s}-sealed.yaml"
          done
          git config user.email "github-actions@users.noreply.github.com"
          git config user.name "github-actions"
          git add "aks-yaml/secrets/${ENV}" || true
          git commit -m "ci: sealed-secrets (${ENV}) [skip ci]" || echo "No changes"
          git push || true

      - name: Patch image registry & tag in overlay
        run: |
          ENV="${{ needs.build.outputs.ENV }}"
          ACR_FQDN="${{ needs.build.outputs.ACR_FQDN }}"
          PATCH="aks-yaml/overlays/${ENV}/patch-images.yaml"
          sed -i "s#__ACR_FQDN__#${ACR_FQDN}#g" "$PATCH"
          if [ "${{ github.event.inputs.pin_sha || 'yes' }}" = "yes" ]; then
            sed -i "s#latest-${ENV}#${{ needs.build.outputs.IMAGE_TAG_SUFFIX }}#g" "$PATCH"
          fi
          git add "$PATCH" || true
          git commit -m "ci: image pin for ${ENV} [skip ci]" || echo "No changes"
          git push || true

      - name: Install Argo CD (Helm)
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm upgrade -i argocd argo/argo-cd \
            --namespace argocd --create-namespace \
            --values aks-yaml/ansible-monitoring-aks/values-argocd.yaml \
            --wait --timeout 10m

      - name: Bootstrap Argo applications
        run: |
          ENV="${{ needs.build.outputs.ENV }}"
          if [ "$ENV" = "prod" ]; then
            kubectl apply -f aks-yaml/argocd/app-secrets-prod.yaml
            kubectl apply -f aks-yaml/argocd/app-prod.yaml
          else
            kubectl apply -f aks-yaml/argocd/app-secrets-dev.yaml
            kubectl apply -f aks-yaml/argocd/app-dev.yaml
          fi
          # Optional: also apply root app if you use it
          # kubectl apply -f aks-yaml/argocd/root-app.yaml

      - name: Show ArgoCD Applications
        run: kubectl get applications.argoproj.io -A
